> 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

## 🧑🏻‍💻 메모리 할당 기법 (메모리 관리 방법)

---

<center>
    <img src="/img/운영체제/5-1-1.png" width="500" height="200" alt="메모리 할당 기법" />
</center>

### ✅ Paging (페이징)

> 페이지를 프레임에 할당하는 고정 분할 방식의 가상 메모리 관리 기법

- 프로세스의 논리 주소 공간(사용자와 프로세스가 바라보는 주소 공간)을 일정한 단위로 자른다 => `page`
- 메모리의 물리 주소 공간(실제 메모리에서 사용되는 공간)을 페이지와 동일한 단위로 자른다 => `Frame`
- **장점**
    - 연속되어 저장될 필요가 없어 메모리에 할당되고 해제되는 과정에서 생기는 **외부 단편화 해결**
- **단점**
    - 더 크게 할당돼서 낭비되는 공간인 **내부 단편화 문제 발생**

### ✅ Segmentation (세그멘테이션)

> 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할해 저장

- **장점**
    - 더 크게 할당돼서 낭비되는 공간인 내부 단편화 해결
- **단점**
    - 메모리에 할당되고 해제되는 과정에서 생기는 **외부 단편화** 발생

### ✅ 페이지드 세그멘테이션

> 세그멘테이션 + 페이징 (둘을 혼합)

- 두 가지의 **장점**을 반영
- **단점**
    - 물리 메모리에 접근하기 위해서 메모리의 접근을 2번 해야 함
- 현대 운영체제는 `페이징`과 `페이지드 세그멘테이션` 기법을 적절히 섞어서 사용하고 있다.

## 🧑🏻‍💻 가상 메모리

---

> 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

- 프로그램이 물리 메모리보다 커도 실행 가능하도록 한다.

### ✅ 가상 메모리의 장점

- 물리 메모리 크기에 제약 받지 않는다.
- 더 많은 프로그램 동시 실행 가능하다. ⇒ 응답시간 유지, CPU이용률과 처리율 ⬆️
- swap에 필요한 입출력이 줄어든다.

### ✅ 가상 주소 공간

> 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현한 공간

- 가상 메모리 시스템에서 가상주소는 메모리나 스왑영역 한 곳 중 위치한다.
- 현재 직접적으로 필요치 않은 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약한다.

### ✅ Demand Paging (요구 페이징)

> 프로그램 실행 시작 시, 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신에 초기에 필요한 것들만 적재하는 전략

- 가상 메모리 시스템에서 많이 사용됨
- 실행과정에서 필요해질 때 페이지들이 적재된다. (**한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.**)
- **장점**
    - 사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄일 수 있다.

✏️ **지역성 이론**

- 공간의 지역성 : 현재 위치와 가까운 데이터에 접근 확률이 높음
- 시간의 지역성 : 최근 접근했던 데이터에 접근할 확률 높음

> `Demand Paging`은 조만간 쓰일 데이터만 메모리에 올리고 당분간 필요하지 않을 것 같은 데이터는 스왑 영역으로 보내는 정책 (지역성 이론을 구현)


### ✅ page fault (페이지 부재)

> 프로그램 실행 시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 실행 시에 필요한 데이터나 코드가 물리적인 RAM에 없는 경우 발생

- 이 경우 운영체제는 해당 데이터 또는 코드를 물리적인 RAM으로 로드하는 작업을 수행 (스왑영역에 있던 것을 메모리로 로드)

<center>
    <img src="/img/운영체제/5-1-2.png" width="400" height="100" alt="스와핑" />
</center>

- page fault(페이지 부재) 시, "swap in"("페이지 교체" 라고 한다.)을 한다.

✏️ **스와핑 (Swapping)**

> 주기억장치에 적재한 하나의 프로세스를 보조기억장치에 잠시 적재했다가 필요할 때 다시 꺼내서 사용하는 메모리 교체 기법

- 가상 메모리 관리는 페이징 단위로 스와핑을 한다.
- `swap-in` : 디스크에 있던 있던 page를 디스크에 read 하는 과정
- `swap-out` : 메모리에 있던 page를 디스크에 write 하는 과정

### ✅ 페이지 교체 원리

> page fault 발생 시, 디스크에서 메모리로 읽어와야 하는데 물리적 메모리가 차있는 경우, 페이지 중 하나를 선택해 보조 저장 장치(스왑 영역)로 보내는 과정

- **페이지 폴트(Page Fault) 발생** **→** **페이지 교체 알고리즘 선택** → **교체할 페이지 선택** (이 때 out 되는 페이지는 victim page) **→** **교체할 페이지를 스왑 영역으로 이동** **→** **새로운 페이지 로드**

<center>
    <img src="/img/운영체제/5-1-3.png" width="400" height="100" alt="페이지 교체" />
</center>

## 🧑🏻‍💻 페이지 교체 알고리즘
---

> 메모리에 올려진 페이지 중 어떤 것을 내리고 어떤 새로운 페이지를 올릴지를 결정하는 규칙
> 

### ✅ FIFO 페이지 교체

- First-In First-Out) 방식 사용
- 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘
    - 장점 : 구현이 간단하다.
    - 단점
        - 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다 (초기 변수 등)
        - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
        - `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 개수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

### ✅ OPT 알고리즘

- 최적 페이지 교체(Optimal Page Replacement)
- **앞으로** 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄
- `Belady의 모순`이 발생하지 않는다
- 주로 비교 연구 목적을 위해 사용앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄⇒ 하지만, 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없기 때문에 수행하기 어려운 알고리즘
- **장점** : 알고리즘 중 가장 낮은 페이지 부재율을 보장
- **단점** : 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문

### ✅ LRU 알고리즘

- LRU 페이지 교체(LRU Page Replacement)`LRU: Least-Recently-Used`
- 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체
- 실제로도 최근에 사용하지 않은 페이지는 앞으로도 사용하지 않을 확률이 높다
- OPT의 경우 미래 예측이지만, LRU의 경우는 과거를 보고 판단하므로 실질적으로 사용이 가능한 알고리즘
- **특징**
    - 대체적으로 `FIFO 알고리즘`보다 우수하고, `OPT알고리즘`보다는 그렇지 못함.OPT보다는 페이지 결함(page fault)이 더 일어날 수 있지만, **실제로 사용할 수 있는 페이지 교체 알고리즘에서는 가장 좋은 방법 중 하나**

### ✅ LFU 페이지 교체

`LFU: Least Frequently Used`

- 참조 횟수가 가장 적은 페이지를 교체하는 방법
- 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘
- **특징**
    - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다
    - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

### ✅ MFU 페이지 교체

- `MFU: Most Frequently Used`
- 참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반
- **특징**
    - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.
    

✏️ **교체 방식**

> 페이지 교체 시, 선정 기준

- Global 교체
    - 메모리 상의 모든 프로세스 페이지에 대해 교체하는 방식
- Local 교체
    - 메모리 상의 자기 프로세스 페이지에서만 교체하는 방식

⇒ 실제로는 전체를 기준으로 페이지를 교체하는 것이 더 효율적 (자기 프로세스 페이지에서만 교체를 하면, 교체를 해야 할 때 각각 모두 교체를 진행해야 하므로 비효율적)

✏️ **스레싱**

> Page fault가 증가하여 CPU 이용률이 급격하게 떨어지는 현상

- CPU 사용률을 높이는 것 ⇒ 동시 실행 프로세스 수를 올리는 것
- 다중 프로그래밍 정도가 계속 늘어나다 보면 어느 순간부터 페이지 부재(page fault)가 과도하게 늘어나 실제 CPU 사용 시간보다 페이지를 교체하는 시간이 더 많이 지게 되는데, 이러한 현상을 스레싱이라 한다.

✏️ **워킹셋**

- 스레싱을 예방하는 방법으로 지역성을 기반으로 가장 많이 사용하는 페이지를 미리 저장해둔 것